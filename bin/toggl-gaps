#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# dependencies = [
#     "requests",
#     "click",
# ]
# ///

"""
Toggl time tracking gap checker.
Shows when you started your day and identifies gaps in time tracking.
"""

import click
from datetime import datetime, date, timedelta
from typing import List, Dict, Optional
import sys

# Import shared Toggl utilities
from toggl_common import (
    get_time_entries,
    parse_time,
    get_project_name
)


def format_duration(seconds: int) -> str:
    """Format duration in seconds to human-readable string."""
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60

    if hours > 0:
        return f"{hours}h {minutes}m"
    else:
        return f"{minutes}m"


def find_gaps(entries: List[Dict], local_tz) -> List[Dict]:
    """Find gaps between time entries."""
    if not entries:
        return []

    # Sort entries by start time
    sorted_entries = sorted(entries, key=lambda e: e['start'])

    gaps = []
    for i in range(len(sorted_entries) - 1):
        current = sorted_entries[i]
        next_entry = sorted_entries[i + 1]

        # Skip if current entry is still running (no stop time)
        if not current.get('stop'):
            continue

        current_end = parse_time(current['stop'], local_tz)
        next_start = parse_time(next_entry['start'], local_tz)

        # Check if there's a gap (ignore gaps less than 10 minutes)
        if next_start > current_end:
            gap_duration = (next_start - current_end).total_seconds()
            if gap_duration >= 600:  # Only track gaps of 10 minutes or more
                gaps.append({
                    'start': current_end,
                    'end': next_start,
                    'duration': gap_duration
                })

    return gaps


@click.command(context_settings={'help_option_names': ['-h', '--help']})
@click.argument('date_arg', required=False)
@click.option('--token', envvar='TOGGL_API_TOKEN', help='Toggl API token (or set TOGGL_API_TOKEN env var)')
def main(date_arg: Optional[str], token: Optional[str]):
    """
    Check Toggl time tracking for gaps.

    DATE_ARG: Date to check in YYYY-MM-DD format (defaults to today)
    """
    if not token:
        click.echo("Error: API token required. Set TOGGL_API_TOKEN environment variable or use --token", err=True)
        sys.exit(1)

    # Parse date argument
    if date_arg:
        try:
            target_date = datetime.strptime(date_arg, '%Y-%m-%d').date()
        except ValueError:
            click.echo(f"Error: Invalid date format '{date_arg}'. Use YYYY-MM-DD", err=True)
            sys.exit(1)
    else:
        target_date = date.today()

    # Get local timezone
    local_tz = datetime.now().astimezone().tzinfo

    # Fetch time entries
    click.echo(f"Fetching time entries for {target_date}...")
    entries = get_time_entries(token, target_date)  # end_date defaults to start_date

    if not entries:
        click.echo(f"\nNo time entries found for {target_date}")
        sys.exit(0)

    # Sort entries by start time
    sorted_entries = sorted(entries, key=lambda e: e['start'])

    # Find when day started
    first_entry = sorted_entries[0]
    day_start = parse_time(first_entry['start'], local_tz)

    click.echo(f"\nüìÖ Date: {target_date}")
    click.echo(f"‚è∞ Day started: {day_start.strftime('%I:%M %p')}")

    # Check if there's a currently running entry
    running_entry = next((e for e in entries if not e.get('stop')), None)
    if running_entry:
        description = running_entry.get('description', '(no description)')
        project_id = running_entry.get('project_id') or running_entry.get('pid')
        if project_id:
            project_name = get_project_name(project_id, token)
            click.echo(f"‚ñ∂Ô∏è  Currently tracking: {description} ({project_name})")
        else:
            click.echo(f"‚ñ∂Ô∏è  Currently tracking: {description}")

    # Find gaps
    gaps = find_gaps(entries, local_tz)

    if gaps:
        click.echo(f"\n‚ö†Ô∏è  Found {len(gaps)} gap(s):\n")
        total_gap_time = 0

        for i, gap in enumerate(gaps, 1):
            duration_str = format_duration(int(gap['duration']))
            start_str = gap['start'].strftime('%I:%M %p')
            end_str = gap['end'].strftime('%I:%M %p')
            click.echo(f"  {i}. {start_str} ‚Üí {end_str} ({duration_str})")
            total_gap_time += gap['duration']

        click.echo(f"\nüìä Total gap time: {format_duration(int(total_gap_time))}")
    else:
        click.echo("\n‚úÖ No gaps found!")

    # Calculate total tracked time
    total_tracked = 0
    for entry in entries:
        if entry.get('duration', 0) > 0:
            total_tracked += entry['duration']
        elif running_entry and entry['id'] == running_entry['id']:
            # Calculate duration for running entry
            start = parse_time(entry['start'], local_tz)
            now = datetime.now(local_tz)
            total_tracked += (now - start).total_seconds()

    click.echo(f"‚è±Ô∏è  Total tracked: {format_duration(int(total_tracked))}")


if __name__ == '__main__':
    main()
