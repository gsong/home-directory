#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# dependencies = [
#     "requests",
#     "click",
# ]
# ///

"""
Toggl time tracking gap checker.
Shows when you started your day and identifies gaps in time tracking.
"""

import sys
from datetime import date, datetime, timedelta
from typing import Dict, List, Optional

import click

# Import shared Toggl utilities
from toggl_common import (
    SECONDS_PER_HOUR,
    SECONDS_PER_MINUTE,
    calculate_entry_duration,
    format_duration_str,
    get_local_timezone,
    get_project_name,
    get_time_entries,
    parse_date_argument,
    parse_time,
    validate_api_token,
)

# Constants
MIN_GAP_SECONDS = 600  # 10 minutes minimum


def find_gaps(entries: List[Dict], local_tz) -> List[Dict]:
    """Find gaps between time entries."""
    if not entries:
        return []

    # Sort entries by start time
    sorted_entries = sorted(entries, key=lambda e: e["start"])

    gaps = []
    for i in range(len(sorted_entries) - 1):
        current = sorted_entries[i]
        next_entry = sorted_entries[i + 1]

        # Skip if current entry is still running (no stop time)
        if not current.get("stop"):
            continue

        current_end = parse_time(current["stop"], local_tz)
        next_start = parse_time(next_entry["start"], local_tz)

        # Check if there's a gap (ignore gaps less than 10 minutes)
        if next_start > current_end:
            gap_duration = (next_start - current_end).total_seconds()
            if gap_duration >= MIN_GAP_SECONDS:
                gaps.append(
                    {"start": current_end, "end": next_start, "duration": gap_duration}
                )

    return gaps


@click.command(context_settings={"help_option_names": ["-h", "--help"]})
@click.argument("date_arg", required=False)
@click.option(
    "--token",
    envvar="TOGGL_API_TOKEN",
    help="Toggl API token (or set TOGGL_API_TOKEN env var)",
)
def main(date_arg: Optional[str], token: Optional[str]):
    """
    Check Toggl time tracking for gaps.

    DATE_ARG: Date to check in YYYY-MM-DD format (defaults to today)
    """
    validate_api_token(token)

    # Parse date argument
    if date_arg:
        target_date = parse_date_argument(date_arg)
    else:
        target_date = date.today()

    # Get local timezone
    local_tz = get_local_timezone()

    # Fetch time entries
    click.echo(f"Fetching time entries for {target_date}...")
    entries = get_time_entries(token, target_date)  # end_date defaults to start_date

    if not entries:
        click.echo(f"\nNo time entries found for {target_date}")
        sys.exit(0)

    # Sort entries by start time
    sorted_entries = sorted(entries, key=lambda e: e["start"])

    # Find when day started
    first_entry = sorted_entries[0]
    day_start = parse_time(first_entry["start"], local_tz)

    click.echo(f"\nüìÖ Date: {target_date}")
    click.echo(f"‚è∞ Day started: {day_start.strftime('%I:%M %p')}")

    # Check if there's a currently running entry
    running_entry = next((e for e in entries if not e.get("stop")), None)
    if running_entry:
        description = running_entry.get("description", "(no description)")
        project_id = running_entry.get("project_id") or running_entry.get("pid")
        if project_id:
            project_name = get_project_name(project_id, token)
            click.echo(f"‚ñ∂Ô∏è  Currently tracking: {description} ({project_name})")
        else:
            click.echo(f"‚ñ∂Ô∏è  Currently tracking: {description}")

    # Find gaps
    gaps = find_gaps(entries, local_tz)

    if gaps:
        click.echo(f"\n‚ö†Ô∏è  Found {len(gaps)} gap(s):\n")
        total_gap_time = 0

        for i, gap in enumerate(gaps, 1):
            duration_str = format_duration_str(int(gap["duration"]))
            start_str = gap["start"].strftime("%I:%M %p")
            end_str = gap["end"].strftime("%I:%M %p")
            click.echo(f"  {i}. {start_str} ‚Üí {end_str} ({duration_str})")
            total_gap_time += gap["duration"]

        click.echo(f"\nüìä Total gap time: {format_duration_str(int(total_gap_time))}")
    else:
        click.echo("\n‚úÖ No gaps found!")

    # Calculate total tracked time
    total_tracked = 0
    for entry in entries:
        total_tracked += calculate_entry_duration(entry, local_tz)

    click.echo(f"‚è±Ô∏è  Total tracked: {format_duration_str(int(total_tracked))}")


if __name__ == "__main__":
    main()
